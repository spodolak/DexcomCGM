{"ast":null,"code":"import matches from 'dom-helpers/matches';\nimport qsa from 'dom-helpers/querySelectorAll';\nimport addEventListener from 'dom-helpers/addEventListener';\nimport React, { useCallback, useRef, useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { useUncontrolledProp } from 'uncontrollable';\nimport usePrevious from '@restart/hooks/usePrevious';\nimport useForceUpdate from '@restart/hooks/useForceUpdate';\nimport useGlobalListener from '@restart/hooks/useGlobalListener';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport DropdownContext from './DropdownContext';\nimport DropdownMenu from './DropdownMenu';\nimport DropdownToggle from './DropdownToggle';\nvar propTypes = {\n  /**\n   * A render prop that returns the root dropdown element. The `props`\n   * argument should spread through to an element containing _both_ the\n   * menu and toggle in order to handle keyboard events for focus management.\n   *\n   * @type {Function ({\n   *   props: {\n   *     onKeyDown: (SyntheticEvent) => void,\n   *   },\n   * }) => React.Element}\n   */\n  children: PropTypes.node,\n  /**\n   * Determines the direction and location of the Menu in relation to it's Toggle.\n   */\n  drop: PropTypes.oneOf(['up', 'left', 'right', 'down']),\n  /**\n   * Controls the focus behavior for when the Dropdown is opened. Set to\n   * `true` to always focus the first menu item, `keyboard` to focus only when\n   * navigating via the keyboard, or `false` to disable completely\n   *\n   * The Default behavior is `false` **unless** the Menu has a `role=\"menu\"`\n   * where it will default to `keyboard` to match the recommended [ARIA Authoring practices](https://www.w3.org/TR/wai-aria-practices-1.1/#menubutton).\n   */\n  focusFirstItemOnShow: PropTypes.oneOf([false, true, 'keyboard']),\n  /**\n   * A css slector string that will return __focusable__ menu items.\n   * Selectors should be relative to the menu component:\n   * e.g. ` > li:not('.disabled')`\n   */\n  itemSelector: PropTypes.string,\n  /**\n   * Align the menu to the 'end' side of the placement side of the Dropdown toggle. The default placement is `top-start` or `bottom-start`.\n   */\n  alignEnd: PropTypes.bool,\n  /**\n   * Whether or not the Dropdown is visible.\n   *\n   * @controllable onToggle\n   */\n  show: PropTypes.bool,\n  /**\n   * Sets the initial show position of the Dropdown.\n   */\n  defaultShow: PropTypes.bool,\n  /**\n   * A callback fired when the Dropdown wishes to change visibility. Called with the requested\n   * `show` value, the DOM event, and the source that fired it: `'click'`,`'keydown'`,`'rootClose'`, or `'select'`.\n   *\n   * ```ts static\n   * function(\n   *   isOpen: boolean,\n   *   event: SyntheticEvent,\n   * ): void\n   * ```\n   *\n   * @controllable show\n   */\n  onToggle: PropTypes.func\n};\nfunction useRefWithUpdate() {\n  var forceUpdate = useForceUpdate();\n  var ref = useRef(null);\n  var attachRef = useCallback(function (element) {\n    ref.current = element; // ensure that a menu set triggers an update for consumers\n\n    forceUpdate();\n  }, [forceUpdate]);\n  return [ref, attachRef];\n}\n/**\n * @displayName Dropdown\n * @public\n */\n\nfunction Dropdown(_ref) {\n  var drop = _ref.drop,\n    alignEnd = _ref.alignEnd,\n    defaultShow = _ref.defaultShow,\n    rawShow = _ref.show,\n    rawOnToggle = _ref.onToggle,\n    _ref$itemSelector = _ref.itemSelector,\n    itemSelector = _ref$itemSelector === void 0 ? '* > *' : _ref$itemSelector,\n    focusFirstItemOnShow = _ref.focusFirstItemOnShow,\n    children = _ref.children;\n  var _useUncontrolledProp = useUncontrolledProp(rawShow, defaultShow, rawOnToggle),\n    show = _useUncontrolledProp[0],\n    onToggle = _useUncontrolledProp[1]; // We use normal refs instead of useCallbackRef in order to populate the\n  // the value as quickly as possible, otherwise the effect to focus the element\n  // may run before the state value is set\n\n  var _useRefWithUpdate = useRefWithUpdate(),\n    menuRef = _useRefWithUpdate[0],\n    setMenu = _useRefWithUpdate[1];\n  var menuElement = menuRef.current;\n  var _useRefWithUpdate2 = useRefWithUpdate(),\n    toggleRef = _useRefWithUpdate2[0],\n    setToggle = _useRefWithUpdate2[1];\n  var toggleElement = toggleRef.current;\n  var lastShow = usePrevious(show);\n  var lastSourceEvent = useRef(null);\n  var focusInDropdown = useRef(false);\n  var toggle = useCallback(function (nextShow, event) {\n    onToggle(nextShow, event);\n  }, [onToggle]);\n  var context = useMemo(function () {\n    return {\n      toggle: toggle,\n      drop: drop,\n      show: show,\n      alignEnd: alignEnd,\n      menuElement: menuElement,\n      toggleElement: toggleElement,\n      setMenu: setMenu,\n      setToggle: setToggle\n    };\n  }, [toggle, drop, show, alignEnd, menuElement, toggleElement, setMenu, setToggle]);\n  if (menuElement && lastShow && !show) {\n    focusInDropdown.current = menuElement.contains(document.activeElement);\n  }\n  var focusToggle = useEventCallback(function () {\n    if (toggleElement && toggleElement.focus) {\n      toggleElement.focus();\n    }\n  });\n  var maybeFocusFirst = useEventCallback(function () {\n    var type = lastSourceEvent.current;\n    var focusType = focusFirstItemOnShow;\n    if (focusType == null) {\n      focusType = menuRef.current && matches(menuRef.current, '[role=menu]') ? 'keyboard' : false;\n    }\n    if (focusType === false || focusType === 'keyboard' && !/^key.+$/.test(type)) {\n      return;\n    }\n    var first = qsa(menuRef.current, itemSelector)[0];\n    if (first && first.focus) first.focus();\n  });\n  useEffect(function () {\n    if (show) maybeFocusFirst();else if (focusInDropdown.current) {\n      focusInDropdown.current = false;\n      focusToggle();\n    } // only `show` should be changing\n  }, [show, focusInDropdown, focusToggle, maybeFocusFirst]);\n  useEffect(function () {\n    lastSourceEvent.current = null;\n  });\n  var getNextFocusedChild = function getNextFocusedChild(current, offset) {\n    if (!menuRef.current) return null;\n    var items = qsa(menuRef.current, itemSelector);\n    var index = items.indexOf(current) + offset;\n    index = Math.max(0, Math.min(index, items.length));\n    return items[index];\n  };\n  useGlobalListener('keydown', function (event) {\n    var _menuRef$current, _toggleRef$current;\n    var key = event.key;\n    var target = event.target;\n    var fromMenu = (_menuRef$current = menuRef.current) == null ? void 0 : _menuRef$current.contains(target);\n    var fromToggle = (_toggleRef$current = toggleRef.current) == null ? void 0 : _toggleRef$current.contains(target); // Second only to https://github.com/twbs/bootstrap/blob/8cfbf6933b8a0146ac3fbc369f19e520bd1ebdac/js/src/dropdown.js#L400\n    // in inscrutability\n\n    var isInput = /input|textarea/i.test(target.tagName);\n    if (isInput && (key === ' ' || key !== 'Escape' && fromMenu)) {\n      return;\n    }\n    if (!fromMenu && !fromToggle) {\n      return;\n    }\n    if (!menuRef.current && key === 'Tab') {\n      return;\n    }\n    lastSourceEvent.current = event.type;\n    switch (key) {\n      case 'ArrowUp':\n        {\n          var next = getNextFocusedChild(target, -1);\n          if (next && next.focus) next.focus();\n          event.preventDefault();\n          return;\n        }\n      case 'ArrowDown':\n        event.preventDefault();\n        if (!show) {\n          onToggle(true, event);\n        } else {\n          var _next = getNextFocusedChild(target, 1);\n          if (_next && _next.focus) _next.focus();\n        }\n        return;\n      case 'Tab':\n        // on keydown the target is the element being tabbed FROM, we need that\n        // to know if this event is relevant to this dropdown (e.g. in this menu).\n        // On `keyup` the target is the element being tagged TO which we use to check\n        // if focus has left the menu\n        addEventListener(document, 'keyup', function (e) {\n          var _menuRef$current2;\n          if (e.key === 'Tab' && !e.target || !((_menuRef$current2 = menuRef.current) != null && _menuRef$current2.contains(e.target))) {\n            onToggle(false, event);\n          }\n        }, {\n          once: true\n        });\n        break;\n      case 'Escape':\n        event.preventDefault();\n        event.stopPropagation();\n        onToggle(false, event);\n        break;\n      default:\n    }\n  });\n  return /*#__PURE__*/React.createElement(DropdownContext.Provider, {\n    value: context\n  }, children);\n}\nDropdown.displayName = 'ReactOverlaysDropdown';\nDropdown.propTypes = propTypes;\nDropdown.Menu = DropdownMenu;\nDropdown.Toggle = DropdownToggle;\nexport default Dropdown;","map":{"version":3,"names":["matches","qsa","addEventListener","React","useCallback","useRef","useEffect","useMemo","PropTypes","useUncontrolledProp","usePrevious","useForceUpdate","useGlobalListener","useEventCallback","DropdownContext","DropdownMenu","DropdownToggle","propTypes","children","node","drop","oneOf","focusFirstItemOnShow","itemSelector","string","alignEnd","bool","show","defaultShow","onToggle","func","useRefWithUpdate","forceUpdate","ref","attachRef","element","current","Dropdown","_ref","rawShow","rawOnToggle","_ref$itemSelector","_useUncontrolledProp","_useRefWithUpdate","menuRef","setMenu","menuElement","_useRefWithUpdate2","toggleRef","setToggle","toggleElement","lastShow","lastSourceEvent","focusInDropdown","toggle","nextShow","event","context","contains","document","activeElement","focusToggle","focus","maybeFocusFirst","type","focusType","test","first","getNextFocusedChild","offset","items","index","indexOf","Math","max","min","length","_menuRef$current","_toggleRef$current","key","target","fromMenu","fromToggle","isInput","tagName","next","preventDefault","_next","e","_menuRef$current2","once","stopPropagation","createElement","Provider","value","displayName","Menu","Toggle"],"sources":["/Users/macbook/Desktop/DexcomCGM/node_modules/react-overlays/esm/Dropdown.js"],"sourcesContent":["import matches from 'dom-helpers/matches';\nimport qsa from 'dom-helpers/querySelectorAll';\nimport addEventListener from 'dom-helpers/addEventListener';\nimport React, { useCallback, useRef, useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { useUncontrolledProp } from 'uncontrollable';\nimport usePrevious from '@restart/hooks/usePrevious';\nimport useForceUpdate from '@restart/hooks/useForceUpdate';\nimport useGlobalListener from '@restart/hooks/useGlobalListener';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport DropdownContext from './DropdownContext';\nimport DropdownMenu from './DropdownMenu';\nimport DropdownToggle from './DropdownToggle';\nvar propTypes = {\n  /**\n   * A render prop that returns the root dropdown element. The `props`\n   * argument should spread through to an element containing _both_ the\n   * menu and toggle in order to handle keyboard events for focus management.\n   *\n   * @type {Function ({\n   *   props: {\n   *     onKeyDown: (SyntheticEvent) => void,\n   *   },\n   * }) => React.Element}\n   */\n  children: PropTypes.node,\n\n  /**\n   * Determines the direction and location of the Menu in relation to it's Toggle.\n   */\n  drop: PropTypes.oneOf(['up', 'left', 'right', 'down']),\n\n  /**\n   * Controls the focus behavior for when the Dropdown is opened. Set to\n   * `true` to always focus the first menu item, `keyboard` to focus only when\n   * navigating via the keyboard, or `false` to disable completely\n   *\n   * The Default behavior is `false` **unless** the Menu has a `role=\"menu\"`\n   * where it will default to `keyboard` to match the recommended [ARIA Authoring practices](https://www.w3.org/TR/wai-aria-practices-1.1/#menubutton).\n   */\n  focusFirstItemOnShow: PropTypes.oneOf([false, true, 'keyboard']),\n\n  /**\n   * A css slector string that will return __focusable__ menu items.\n   * Selectors should be relative to the menu component:\n   * e.g. ` > li:not('.disabled')`\n   */\n  itemSelector: PropTypes.string,\n\n  /**\n   * Align the menu to the 'end' side of the placement side of the Dropdown toggle. The default placement is `top-start` or `bottom-start`.\n   */\n  alignEnd: PropTypes.bool,\n\n  /**\n   * Whether or not the Dropdown is visible.\n   *\n   * @controllable onToggle\n   */\n  show: PropTypes.bool,\n\n  /**\n   * Sets the initial show position of the Dropdown.\n   */\n  defaultShow: PropTypes.bool,\n\n  /**\n   * A callback fired when the Dropdown wishes to change visibility. Called with the requested\n   * `show` value, the DOM event, and the source that fired it: `'click'`,`'keydown'`,`'rootClose'`, or `'select'`.\n   *\n   * ```ts static\n   * function(\n   *   isOpen: boolean,\n   *   event: SyntheticEvent,\n   * ): void\n   * ```\n   *\n   * @controllable show\n   */\n  onToggle: PropTypes.func\n};\n\nfunction useRefWithUpdate() {\n  var forceUpdate = useForceUpdate();\n  var ref = useRef(null);\n  var attachRef = useCallback(function (element) {\n    ref.current = element; // ensure that a menu set triggers an update for consumers\n\n    forceUpdate();\n  }, [forceUpdate]);\n  return [ref, attachRef];\n}\n/**\n * @displayName Dropdown\n * @public\n */\n\n\nfunction Dropdown(_ref) {\n  var drop = _ref.drop,\n      alignEnd = _ref.alignEnd,\n      defaultShow = _ref.defaultShow,\n      rawShow = _ref.show,\n      rawOnToggle = _ref.onToggle,\n      _ref$itemSelector = _ref.itemSelector,\n      itemSelector = _ref$itemSelector === void 0 ? '* > *' : _ref$itemSelector,\n      focusFirstItemOnShow = _ref.focusFirstItemOnShow,\n      children = _ref.children;\n\n  var _useUncontrolledProp = useUncontrolledProp(rawShow, defaultShow, rawOnToggle),\n      show = _useUncontrolledProp[0],\n      onToggle = _useUncontrolledProp[1]; // We use normal refs instead of useCallbackRef in order to populate the\n  // the value as quickly as possible, otherwise the effect to focus the element\n  // may run before the state value is set\n\n\n  var _useRefWithUpdate = useRefWithUpdate(),\n      menuRef = _useRefWithUpdate[0],\n      setMenu = _useRefWithUpdate[1];\n\n  var menuElement = menuRef.current;\n\n  var _useRefWithUpdate2 = useRefWithUpdate(),\n      toggleRef = _useRefWithUpdate2[0],\n      setToggle = _useRefWithUpdate2[1];\n\n  var toggleElement = toggleRef.current;\n  var lastShow = usePrevious(show);\n  var lastSourceEvent = useRef(null);\n  var focusInDropdown = useRef(false);\n  var toggle = useCallback(function (nextShow, event) {\n    onToggle(nextShow, event);\n  }, [onToggle]);\n  var context = useMemo(function () {\n    return {\n      toggle: toggle,\n      drop: drop,\n      show: show,\n      alignEnd: alignEnd,\n      menuElement: menuElement,\n      toggleElement: toggleElement,\n      setMenu: setMenu,\n      setToggle: setToggle\n    };\n  }, [toggle, drop, show, alignEnd, menuElement, toggleElement, setMenu, setToggle]);\n\n  if (menuElement && lastShow && !show) {\n    focusInDropdown.current = menuElement.contains(document.activeElement);\n  }\n\n  var focusToggle = useEventCallback(function () {\n    if (toggleElement && toggleElement.focus) {\n      toggleElement.focus();\n    }\n  });\n  var maybeFocusFirst = useEventCallback(function () {\n    var type = lastSourceEvent.current;\n    var focusType = focusFirstItemOnShow;\n\n    if (focusType == null) {\n      focusType = menuRef.current && matches(menuRef.current, '[role=menu]') ? 'keyboard' : false;\n    }\n\n    if (focusType === false || focusType === 'keyboard' && !/^key.+$/.test(type)) {\n      return;\n    }\n\n    var first = qsa(menuRef.current, itemSelector)[0];\n    if (first && first.focus) first.focus();\n  });\n  useEffect(function () {\n    if (show) maybeFocusFirst();else if (focusInDropdown.current) {\n      focusInDropdown.current = false;\n      focusToggle();\n    } // only `show` should be changing\n  }, [show, focusInDropdown, focusToggle, maybeFocusFirst]);\n  useEffect(function () {\n    lastSourceEvent.current = null;\n  });\n\n  var getNextFocusedChild = function getNextFocusedChild(current, offset) {\n    if (!menuRef.current) return null;\n    var items = qsa(menuRef.current, itemSelector);\n    var index = items.indexOf(current) + offset;\n    index = Math.max(0, Math.min(index, items.length));\n    return items[index];\n  };\n\n  useGlobalListener('keydown', function (event) {\n    var _menuRef$current, _toggleRef$current;\n\n    var key = event.key;\n    var target = event.target;\n    var fromMenu = (_menuRef$current = menuRef.current) == null ? void 0 : _menuRef$current.contains(target);\n    var fromToggle = (_toggleRef$current = toggleRef.current) == null ? void 0 : _toggleRef$current.contains(target); // Second only to https://github.com/twbs/bootstrap/blob/8cfbf6933b8a0146ac3fbc369f19e520bd1ebdac/js/src/dropdown.js#L400\n    // in inscrutability\n\n    var isInput = /input|textarea/i.test(target.tagName);\n\n    if (isInput && (key === ' ' || key !== 'Escape' && fromMenu)) {\n      return;\n    }\n\n    if (!fromMenu && !fromToggle) {\n      return;\n    }\n\n    if (!menuRef.current && key === 'Tab') {\n      return;\n    }\n\n    lastSourceEvent.current = event.type;\n\n    switch (key) {\n      case 'ArrowUp':\n        {\n          var next = getNextFocusedChild(target, -1);\n          if (next && next.focus) next.focus();\n          event.preventDefault();\n          return;\n        }\n\n      case 'ArrowDown':\n        event.preventDefault();\n\n        if (!show) {\n          onToggle(true, event);\n        } else {\n          var _next = getNextFocusedChild(target, 1);\n\n          if (_next && _next.focus) _next.focus();\n        }\n\n        return;\n\n      case 'Tab':\n        // on keydown the target is the element being tabbed FROM, we need that\n        // to know if this event is relevant to this dropdown (e.g. in this menu).\n        // On `keyup` the target is the element being tagged TO which we use to check\n        // if focus has left the menu\n        addEventListener(document, 'keyup', function (e) {\n          var _menuRef$current2;\n\n          if (e.key === 'Tab' && !e.target || !((_menuRef$current2 = menuRef.current) != null && _menuRef$current2.contains(e.target))) {\n            onToggle(false, event);\n          }\n        }, {\n          once: true\n        });\n        break;\n\n      case 'Escape':\n        event.preventDefault();\n        event.stopPropagation();\n        onToggle(false, event);\n        break;\n\n      default:\n    }\n  });\n  return /*#__PURE__*/React.createElement(DropdownContext.Provider, {\n    value: context\n  }, children);\n}\n\nDropdown.displayName = 'ReactOverlaysDropdown';\nDropdown.propTypes = propTypes;\nDropdown.Menu = DropdownMenu;\nDropdown.Toggle = DropdownToggle;\nexport default Dropdown;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}