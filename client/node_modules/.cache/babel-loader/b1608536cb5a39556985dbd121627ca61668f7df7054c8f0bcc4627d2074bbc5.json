{"ast":null,"code":"import warning from 'tiny-warning';\nimport { createRule } from 'jss';\nvar now = Date.now();\nvar fnValuesNs = \"fnValues\" + now;\nvar fnRuleNs = \"fnStyle\" + ++now;\nvar functionPlugin = function functionPlugin() {\n  return {\n    onCreateRule: function onCreateRule(name, decl, options) {\n      if (typeof decl !== 'function') return null;\n      var rule = createRule(name, {}, options);\n      rule[fnRuleNs] = decl;\n      return rule;\n    },\n    onProcessStyle: function onProcessStyle(style, rule) {\n      // We need to extract function values from the declaration, so that we can keep core unaware of them.\n      // We need to do that only once.\n      // We don't need to extract functions on each style update, since this can happen only once.\n      // We don't support function values inside of function rules.\n      if (fnValuesNs in rule || fnRuleNs in rule) return style;\n      var fnValues = {};\n      for (var prop in style) {\n        var value = style[prop];\n        if (typeof value !== 'function') continue;\n        delete style[prop];\n        fnValues[prop] = value;\n      }\n      rule[fnValuesNs] = fnValues;\n      return style;\n    },\n    onUpdate: function onUpdate(data, rule, sheet, options) {\n      var styleRule = rule;\n      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object\n      // will be returned from that function.\n\n      if (fnRule) {\n        // Empty object will remove all currently defined props\n        // in case function rule returns a falsy value.\n        styleRule.style = fnRule(data) || {};\n        if (process.env.NODE_ENV === 'development') {\n          for (var prop in styleRule.style) {\n            if (typeof styleRule.style[prop] === 'function') {\n              process.env.NODE_ENV !== \"production\" ? warning(false, '[JSS] Function values inside function rules are not supported.') : void 0;\n              break;\n            }\n          }\n        }\n      }\n      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.\n\n      if (fnValues) {\n        for (var _prop in fnValues) {\n          styleRule.prop(_prop, fnValues[_prop](data), options);\n        }\n      }\n    }\n  };\n};\nexport default functionPlugin;","map":{"version":3,"names":["warning","createRule","now","Date","fnValuesNs","fnRuleNs","functionPlugin","onCreateRule","name","decl","options","rule","onProcessStyle","style","fnValues","prop","value","onUpdate","data","sheet","styleRule","fnRule","process","env","NODE_ENV","_prop"],"sources":["/Users/macbook/Desktop/DexcomCGM/client/node_modules/jss-plugin-rule-value-function/dist/jss-plugin-rule-value-function.esm.js"],"sourcesContent":["import warning from 'tiny-warning';\nimport { createRule } from 'jss';\n\nvar now = Date.now();\nvar fnValuesNs = \"fnValues\" + now;\nvar fnRuleNs = \"fnStyle\" + ++now;\n\nvar functionPlugin = function functionPlugin() {\n  return {\n    onCreateRule: function onCreateRule(name, decl, options) {\n      if (typeof decl !== 'function') return null;\n      var rule = createRule(name, {}, options);\n      rule[fnRuleNs] = decl;\n      return rule;\n    },\n    onProcessStyle: function onProcessStyle(style, rule) {\n      // We need to extract function values from the declaration, so that we can keep core unaware of them.\n      // We need to do that only once.\n      // We don't need to extract functions on each style update, since this can happen only once.\n      // We don't support function values inside of function rules.\n      if (fnValuesNs in rule || fnRuleNs in rule) return style;\n      var fnValues = {};\n\n      for (var prop in style) {\n        var value = style[prop];\n        if (typeof value !== 'function') continue;\n        delete style[prop];\n        fnValues[prop] = value;\n      }\n\n      rule[fnValuesNs] = fnValues;\n      return style;\n    },\n    onUpdate: function onUpdate(data, rule, sheet, options) {\n      var styleRule = rule;\n      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object\n      // will be returned from that function.\n\n      if (fnRule) {\n        // Empty object will remove all currently defined props\n        // in case function rule returns a falsy value.\n        styleRule.style = fnRule(data) || {};\n\n        if (process.env.NODE_ENV === 'development') {\n          for (var prop in styleRule.style) {\n            if (typeof styleRule.style[prop] === 'function') {\n              process.env.NODE_ENV !== \"production\" ? warning(false, '[JSS] Function values inside function rules are not supported.') : void 0;\n              break;\n            }\n          }\n        }\n      }\n\n      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.\n\n      if (fnValues) {\n        for (var _prop in fnValues) {\n          styleRule.prop(_prop, fnValues[_prop](data), options);\n        }\n      }\n    }\n  };\n};\n\nexport default functionPlugin;\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,cAAc;AAClC,SAASC,UAAU,QAAQ,KAAK;AAEhC,IAAIC,GAAG,GAAGC,IAAI,CAACD,GAAG,CAAC,CAAC;AACpB,IAAIE,UAAU,GAAG,UAAU,GAAGF,GAAG;AACjC,IAAIG,QAAQ,GAAG,SAAS,GAAG,EAAEH,GAAG;AAEhC,IAAII,cAAc,GAAG,SAASA,cAAcA,CAAA,EAAG;EAC7C,OAAO;IACLC,YAAY,EAAE,SAASA,YAAYA,CAACC,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAE;MACvD,IAAI,OAAOD,IAAI,KAAK,UAAU,EAAE,OAAO,IAAI;MAC3C,IAAIE,IAAI,GAAGV,UAAU,CAACO,IAAI,EAAE,CAAC,CAAC,EAAEE,OAAO,CAAC;MACxCC,IAAI,CAACN,QAAQ,CAAC,GAAGI,IAAI;MACrB,OAAOE,IAAI;IACb,CAAC;IACDC,cAAc,EAAE,SAASA,cAAcA,CAACC,KAAK,EAAEF,IAAI,EAAE;MACnD;MACA;MACA;MACA;MACA,IAAIP,UAAU,IAAIO,IAAI,IAAIN,QAAQ,IAAIM,IAAI,EAAE,OAAOE,KAAK;MACxD,IAAIC,QAAQ,GAAG,CAAC,CAAC;MAEjB,KAAK,IAAIC,IAAI,IAAIF,KAAK,EAAE;QACtB,IAAIG,KAAK,GAAGH,KAAK,CAACE,IAAI,CAAC;QACvB,IAAI,OAAOC,KAAK,KAAK,UAAU,EAAE;QACjC,OAAOH,KAAK,CAACE,IAAI,CAAC;QAClBD,QAAQ,CAACC,IAAI,CAAC,GAAGC,KAAK;MACxB;MAEAL,IAAI,CAACP,UAAU,CAAC,GAAGU,QAAQ;MAC3B,OAAOD,KAAK;IACd,CAAC;IACDI,QAAQ,EAAE,SAASA,QAAQA,CAACC,IAAI,EAAEP,IAAI,EAAEQ,KAAK,EAAET,OAAO,EAAE;MACtD,IAAIU,SAAS,GAAGT,IAAI;MACpB,IAAIU,MAAM,GAAGD,SAAS,CAACf,QAAQ,CAAC,CAAC,CAAC;MAClC;;MAEA,IAAIgB,MAAM,EAAE;QACV;QACA;QACAD,SAAS,CAACP,KAAK,GAAGQ,MAAM,CAACH,IAAI,CAAC,IAAI,CAAC,CAAC;QAEpC,IAAII,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;UAC1C,KAAK,IAAIT,IAAI,IAAIK,SAAS,CAACP,KAAK,EAAE;YAChC,IAAI,OAAOO,SAAS,CAACP,KAAK,CAACE,IAAI,CAAC,KAAK,UAAU,EAAE;cAC/CO,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAGxB,OAAO,CAAC,KAAK,EAAE,gEAAgE,CAAC,GAAG,KAAK,CAAC;cACjI;YACF;UACF;QACF;MACF;MAEA,IAAIc,QAAQ,GAAGM,SAAS,CAAChB,UAAU,CAAC,CAAC,CAAC;;MAEtC,IAAIU,QAAQ,EAAE;QACZ,KAAK,IAAIW,KAAK,IAAIX,QAAQ,EAAE;UAC1BM,SAAS,CAACL,IAAI,CAACU,KAAK,EAAEX,QAAQ,CAACW,KAAK,CAAC,CAACP,IAAI,CAAC,EAAER,OAAO,CAAC;QACvD;MACF;IACF;EACF,CAAC;AACH,CAAC;AAED,eAAeJ,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}